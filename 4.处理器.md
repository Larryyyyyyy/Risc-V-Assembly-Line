# 4.处理器

## 4.1引言

### 4.1.1一种基本的RISC-V实现

我们将实现RISC-V的一个核心子集：

- 存储器访问指令**load word（lw）**和**store word（sw）**。
- 算术逻辑指令**add**，**sub**，**and**，**or**。
- 条件分支指令**branch if equal（beq）**。

### 4.1.2实现概述

实现每条指令的前两条步骤是相同的：

1. **PC**发送到指令所在的存储单元，并从中取出指令。
2. 根据指令的某些字段选择要读取的一个或两个寄存器。对于**lw**指令，只需要读取个寄存器，但大多数其他指令需要读取两个寄存器。

所有类型的指令在读取寄存器后都使用**算术逻辑单元（ALU）**。

- 存储器访问指令用**ALU**进行地址计算。
- 算术逻辑指令用**ALU**来执行运算。
- 条件分支指令用**ALU**进行比较。

但是经过 ALU后：

- 存储器访问指令需要访问存储器以读取数据或存储数据。
- 算术逻辑指令或载入指令需要将来自ALU或存储器的数据写回寄存器。
- 条件分支指令需要根据比较结果更改下一条指令的地址；否则，下一条指令的地址会通过PC加4来获得。

![image-20251009111156158](.\pictures\image-20251009111156158.png)

**忽略的内容**

- 上面的图对于多个数据流的输入缺少了**多选器**。
- 一些功能单元的控制依赖于当前执行的指令类型。但是**ALU**不是，它需要新增的控制线确定做哪种运算。

![image-20251014183901352](.\pictures\image-20251014183901352.png)

上面的图已经实现了**控制器**，**存储器**，**运算器**。

## 4.2逻辑设计的一般方法

RISC-V实现中的数据通路包含两种逻辑单元：**处理数据值的单元**和**存储状态的单元**。

- 处理数据值的单元是**组合逻辑**。组合逻辑单元没有内部存储功能，对于相同的输入有相同的输出。
- 其他单元则是**包含状态**的，有内部存储，就是**状态单元**。一个状态单元至少有两个输人和一个输出。
  - 输入：**要写入状态单元的数据值**和**决定何时写入数据值的时钟信号**。
  - 输出：提供了在前一个时钟周期写入单元的数据值。

包含状态的逻辑部件也被称为**时序的**，因为其输出取决于输入和内部状态。

---

**时钟同步方法**

> **时钟同步方法**：用来确定数据相对于时钟何时稳定和有效的方法。
> **边沿触发的时钟**：所有状态的改变发生于时钟边沿的机制。
> **控制信号**：用来决定多选器选择或指示功能单元操作的信号；它与数据信号相对应，数据信号包含功能单元所操作的信息。

**时钟同步方法(clocking methodology)**规定了信号可以读出和写入的时间。

为简单起见，假定我们采用**边沿触发的时钟(edge-triggeredclocking)**，即存储在时序逻辑单元中的所有值仅在时钟边沿更新，这是从低电平快速跳变到高电平（反之亦然）的过程。

所有组合逻辑单元都必须从状态单元集合接收输入，并将输出写入状态单元集合。其输入是之前某时钟周期写入的值，输出的值可以在后续时钟周期使用。

如果状态单元在每个有效时钟边沿都进行写入则可忽略**写控制信号(controlsignal)**。反之则反之。

![image-20251014185656557](.\pictures\image-20251014185656557.png)

---

> **有效**：信号为逻辑高或真。
>
> **无效**：信号为逻辑低或假。

在32位RISC-V指令系统体系结构，几乎所有的状态单元和逻辑单元的输入和输出都是32位，因为处理器处理的大部分数据的宽度是32位。

## 4.3建立数据通路

> **数据通路单元**：一个用来操作或保存处理器中数据的单元。在RISC-V实现中，数据通路单元包括指令存储器、数据存储器、寄存器堆、ALU和加法器。
> **程序计数器**：包含当前程序正在执行的指令地址的寄存器。

![image-20251014190525685](.\pictures\image-20251014190525685.png)

- `a)`为**存储单元**，用于存储程序的指令，并根据给定地址提供指令。
- `b)`为**程序计数器(PC)**，它用于保存当前指令的地址。
- `c)`为一个加法器来增加PC的值以获得下一条指令的地址。这个加法器是一个组合逻辑电路，可由ALU实现，只需将其中的控制信号设为总是进行加法运算即可。

执行一条指令：从存储器中取出指令。增加程序计数器的值，使其指向下一条指令，即向后移动4个字节。

![image-20251014190852221](.\pictures\image-20251014190852221.png)

处理器的32个通用寄存器位于被称为**寄存器堆**的结构中。

> **寄存器堆**：包含一系列寄存器的状态单元，可通过所提供的寄存器号进行读写。

---

以R型指令（涉及逻辑和运算的指令）为例。

R型指令有三个寄存器操作数，每条指令需要从寄存器堆中读出两个数据字，再写入一个数据字。

- **读一个数据字**：一个指定要读寄存器号的输入，一个从寄存器堆读出的输出。
- **写一个数据字**：一个输入指定要写的寄存器号；另一个输入提供要写入寄存器的数据。

寄存器堆根据输入的寄存器号输出相应寄存器的内容。

写操作由写控制信号控制，在写操作发生的时钟边沿，写控制信号必须是有效的。

![image-20251014192518538](.\pictures\image-20251014192518538.png)

输入的寄存器号为5位宽，（因为有32个寄存器），数据输入总线和两个数据输出总线也均为32位宽。

略带提一下**ALU**：它读取两个32位输入并产生一个32位输出，还有一个1位输出指示其结果是否为0。

---

再考虑存取指令：

这类指令通过将基址寄存器`x2`与指令中包含的12位有符号偏移量相加，得到存储器地址。也会用到寄存器`x1`读出或写入数据。

所以上述**寄存器堆**和**ALU**都会被用到。

此外，还需要将指令中的12位偏移量**符号扩展(sign-extend)**为32位有符号数，以及一个执行读写操作的**数据存储单元**。数据存储单元在存储指令时被写入，所以它有读写控制信号、地址输入和写入存储器的数据输入。

> **符号扩展**：为增加数据的长度，将原数据的最高位复制到新数据多出来的高位。

![image-20251014193444026](.\pictures\image-20251014193444026.png)

---

`beq`指令有三个操作数，其中两个寄存器用于比较是否相等，另一个是12位偏移量，用于计算相对于分支指令所在地址的**分支目标地址**。它的指令格式是`beq x1, x2, offset`。

为实现beq指令，需将PC值与符号扩展后的指令偏移量相加以得到分支目标地址。

> **分支目标地址**：分支指令中指定的地址，如果分支发生，该地址成为新的程序计数器的值。在RISC-V体系结构中，分支目标地址为该指令的偏移量字段与分支指令所在地址的和。

> **分支发生**：一种分支指令，其分支条件满足，程序计数器变为分支目标地址，所有无条件分支指令都是发生的分支。

> **分支未发生**：一种分支指令，其分支条件不成立，程序计数器变为分支指令的下一条指令的地址。

分支指令的数据通路需要执行两个操作：**计算分支目标地址**和**检测分支条件**。

![image-20251014194040547](.\pictures\image-20251014194040547.png)

---

**建立一个简单的数据通路**

这个**最简单**的数据通路在每个时钟周期执行一条指令。

这意味着每条指令在执行过程中的任何数据通路单元都只能使用一次，如果需要多次使用某数据通路单元，则要将其复制多份。

因此，需要一个**指令存储器**和**一个与之分开的数据存储器**。尽管还有一些功能单元需要多份，但很多功能单元可以在不同的指令流动中被共享。

为在两个不同类指令之间共享数据通路单元，需要允许一个单元有多个输入，我们用多路选择器和控制信号在多个输入中进行选择。

**我们为建立只有一个寄存器堆和一个ALU的数据通路，需支持ALU的第二个输入和要存入寄存器堆的数据都有两个不同的来源**。因此，在ALU的输入端和寄存器堆的数据输入端分别添加一个多路选择器。

![image-20251014195306395](.\pictures\image-20251014195306395.png)

现在，把**取指令数据通路**、**R型指令和存储类指令数据通路**、**分支指令数据通路**合并，得到RISC-V指令系统核心集的一个简单数据通路。

![image-20251014195855863](.\pictures\image-20251014195855863.png)

## 4.4一个简单的实现方案

### 4.4.1ALU控制

**RISC-V ALU**定义了四根输入控制线的以下四种组合：

| ALU控制线 | 功能     |
| --------- | -------- |
| `0000`    | AND      |
| `0001`    | OR       |
| `0010`    | add      |
| `0110`    | subtract |

根据不同指令类型，**ALU**执行以上四种功能中一种：

- `load`和`store`：ALU做加法计算存储器地址。
- R型指令，根据`funct7`和`funct3`字段执行这四种中的一种。
- 条件分支指令，ALU将两个操作数做减法并检测结果是否为0。

4位ALU的输入控制信号可由一个小型控制单元产生，其输入是指令的`funct7`和`funct3`和`ALUOp`字段。

| 指令操作码 | ALUOp | 操作            | funct7字段 | funct3字段 | ALU期望行为 | ALU控制输入 |
| ---------- | ----- | --------------- | ---------- | ---------- | ----------- | ----------- |
| `lw`       | `00`  | load word       | `xxxxxxx`  | `xxx`      | add         | 0010        |
| `sw`       | `00`  | store word      | `xxxxxxx`  | `xxx`      | add         | 0010        |
| `beq`      | `01`  | branch if equal | `xxxxxxx`  | `xxx`      | subtract    | 0110        |
| R-type     | `10`  | add             | `0000000`  | `000`      | add         | 0010        |
| R-type     | `10`  | sub             | `0100000`  | `000`      | subtract    | 0110        |
| R-type     | `10`  | and             | `0000000`  | `111`      | AND         | 0000        |
| R-type     | `10`  | or              | `0000000`  | `110`      | OR          | 0001        |

**多级控制**：上面通过**ALUOp**用作**ALU**的输入控制信号，再生成实际信号来控制**ALU**。这样可以减小控制单元的规模。

---

现在我们要一张**真值表**设计一个小逻辑单元：识别可能的取值并生成恰当的ALU控制信号。

| ALUOp  |        | funct7字段 |       |       |       |       |       |       | funct3字段 |       |       | 操作 |
| ------ | ------ | ---------- | ----- | ----- | ----- | ----- | ----- | ----- | ---------- | ----- | ----- | ---- |
| ALUOp1 | ALUOp0 | I[31]      | I[30] | I[29] | I[28] | I[27] | I[26] | I[25] | I[14]      | I[13] | I[12] |      |
| 0      | 0      | x          | x     | x     | x     | x     | x     | x     | x          | x     | x     | 0010 |
| x      | 1      | x          | x     | x     | x     | x     | x     | x     | x          | x     | x     | 0110 |
| 1      | x      | 0          | 0     | 0     | 0     | 0     | 0     | 0     | 0          | 0     | 0     | 0010 |
| 1      | x      | 0          | 1     | 0     | 0     | 0     | 0     | 0     | 0          | 0     | 0     | 0110 |
| 1      | x      | 0          | 0     | 0     | 0     | 0     | 0     | 0     | 1          | 1     | 1     | 0000 |
| 1      | x      | 0          | 0     | 0     | 0     | 0     | 0     | 0     | 1          | 1     | 0     | 0001 |

### 4.4.2设计主控制单元

RISC-V通过复杂指令格式简化了硬件：

- S型指令将立即数拆开为两部分，使得目的寄存器始终在指令的第11至7位。
- SB与S、UJ与U这两组指令具有相同字段，但是立即数位置相反。奇怪的设计降低了立即数生成器中多路复用器的端口数量。
  ![image-20251016102532654](.\pictures\image-20251016102532654.png)

下面给出了增加**ALU控制模块**、**状态单元的写信号**、**数据存储器的读信号**和**多路选择器的控制信号**的数据通路图。

![image-20251016102902651](.\pictures\image-20251016102902651.png)

我们先来看看ALUOp以外的六个控制信号如何工作。

| 信号名     | 无效时的效果（置0）                                          | 有效时的效果（置1）                                          |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `RegWrite` | 无                                                           | 被写的寄存器号来自Write register信号的输入，数据来自Write data信号的输入 |
| `ALUSrc`   | 第二个ALU操作数来自第二个寄存器堆的输出（即 Read data 2 信号的输出） | 第二个ALU操作数是指令的低12位符号扩展                        |
| `PCSrc`    | PC值被adder的输出所替换，即PC+4得值                          | PC值被adder的输出所替换，即分支目标                          |
| `MemRead`  | 无                                                           | 读地址由Address信号的输入指定，输出到Read data信号的输出中   |
| `MemWrite` | 无                                                           | 写地址由Address信号的输入指定，写入内容是Write data信号的输入中的值 |
| `MemtoReg` | 寄存器写数据得输入值来自ALU                                  | 寄存器写数据的输入值来自数据存储器                           |

下面给出带有控制单元的简单数据通路：

![image-20251016104502612](.\pictures\image-20251016104502612.png)

接着我们需要定义每个操作码的取值下（即指令类型）每个控制信号的取值。

| Instr                   | ALUSrc | MemtoReg | RegWrite | MemRead | MemWrite | Branch | ALUOp |
| ----------------------- | ------ | -------- | -------- | ------- | -------- | ------ | ----- |
| `R-type`<br />`0110011` | `0`    | `0`      | `1`      | `0`     | `0`      | `0`    | `10`  |
| `lw`<br />`0000011`     | `1`    | `1`      | `1`      | `1`     | `0`      | `0`    | `00`  |
| `sw`<br />`0100011`     | `1`    | `x`      | `0`      | `0`     | `1`      | `0`    | `00`  |
| `beq`<br />`1100011`    | `0`    | `x`      | `0`      | `0`     | `0`      | `1`    | `01`  |

> `x`表示无关。

### 4.4.3数据通路操作

下面介绍三类指令在执行中按信息的流动顺序得到的步骤：

**R-type**

1. 取出指令，PC自增。
2. 从寄存器堆读出两个寄存器`x2`和`x3`，同时主控制单元在此步骤计算控制信号。
3. 根据部分操作码确定ALU的功能，对从寄存器堆读出的数据进行操作。
4. 将ALU的结果写入寄存器堆中的目标寄存器（`x1`）。

---

**load**

1. 从指令存储器中取出指令，PC自增。
2. 从寄存器堆读出寄存器（`x2`）的值。
3. ALU将从寄存器堆中读出的值和符号扩展后的指令中的12位（偏移量）相加。
4. 将ALU的结果用作数据存储器的地址。
5. 将从存储器读出的数据写入寄存器堆（`x1`）。

---

**beq**

1. 从指令存储器中取出指令，PC自增。
2. 从寄存器堆中读出两个寄存器`x1`和`x2`。
3. ALU将从寄存器堆读出的两数相减。PC与左移一位、符号扩展的指令中的12位（偏移）相加，结果是分支目标地址。
4. ALU的零输出决定将哪个加法器的结果写入PC。

### 4.4.4控制的约束

教材对数据通路的设计在此停步。

如要继续，我们还需要实现更多的指令，可能需要更多的控制信号与多路选择器。

| Instr                   | ALUSrc | MemtoReg | RegWrite | MemRead | MemWrite | Branch | ALUOp | RegDst | Jump |
| ----------------------- | ------ | -------- | -------- | ------- | -------- | ------ | ----- | ------ | ---- |
| `R-type`<br />`0110011` | `0`    | `0`      | `1`      | `0`     | `0`      | `0`    | `10`  | `0`    | `0`  |
| `lw`<br />`0000011`     | `1`    | `1`      | `1`      | `1`     | `0`      | `0`    | `00`  | `0`    | `0`  |
| `sw`<br />`0100011`     | `1`    | `x`      | `0`      | `0`     | `1`      | `0`    | `00`  | `x`    | `0`  |
| `beq`<br />`1100011`    | `0`    | `x`      | `0`      | `0`     | `0`      | `1`    | `01`  | `x`    | `0`  |
| `jal`<br />`1101111`    | `x`    | `x`      | `1`      | `0`     | `0`      | `x`    | `xx`  | `1`    | `1`  |
| `jalr`<br />`1100111`   | `1`    | `x`      | `1`      | `0`     | `0`      | `0`    | `00`  | `1`    | `j`  |

> 多出来的控制信号参照：
> 想象多出一条Jump控制信号与Branch和Zero信号的**与门**输出添加一个**或门**，取代原来的与门输出信号。
> 想象多出一条RegDst控制信号影响一个输入为右上和右下两个多路选择器的输出的多路选择器，其输出影响Write Data。

### 4.4.5为什么现在不使用单周期实现

**效率太低**：单周期设计中时钟周期对于每条指令必须等长。处理器的最长路径决定了时钟周期。（必须`load`）

## 4.5多周期实现

**多周期**：一条指令的执行被分成多个时钟周期完成，每个周期只完成指令执行的一个阶段（或部分阶段）。

其实现：

- 允许每个指令多次使用同一个功能单元（不同周期），减少所需的硬件数量。
- 允许指令采用不同数量的时钟周期。

## 4.6流水线概述

**流水线**是一种能使多条指令重叠执行的实现技术。

RISC-V指令执行通常包含五个步骤：

1. 从存储器中取出指令。
2. 读寄存器并译码指令。
3. 执行操作或计算地址。
4. 访问数据存储器中的操作数（如有必要）。
5. 将结果写入寄存器（如有必要）。

给出一个情境，在此我们假设主要功能单元的操作时间为：

| 指令类型 | 取指令 | 读寄存器 | ALU操作 | 数据存取 | 写寄存器 | 总时间 |
| -------- | ------ | -------- | ------- | -------- | -------- | ------ |
| lw       | 200ps  | 100ps    | 200ps   | 200ps    | 100ps    | 800ps  |
| sw       | 200ps  | 100ps    | 200ps   | 200ps    |          | 700ps  |
| R-type   | 200ps  | 100ps    | 200ps   |          | 100ps    | 600ps  |
| beq      | 200ps  | 100ps    | 200ps   |          |          | 500ps  |

单周期设计必须满足最慢的指令的时间作为时间间隔。

流水线设计必须满足最慢的单元操作时间作为单元操作时间间隔。
如果流水线各阶段操作平衡，那么流水线处理器上的指令执行时间理想化为：
$$
T_{流水线}=\frac{T_{非流水线}}{流水线级数}
$$
**在理想和大量指令条件下，流水线带来加速比约等于流水线级数**。

流水线技术通过**提高指令吞吐率**来提高性能，而**不是减少单个指令的执行时间**。

### 4.6.1面向流水线的指令系统设计

RISC-V在流水线指令系统设计的优势：

1. 所有RISC-V指令长度相同。
2. RISC-V指令格式少，源寄存器和目标寄存器字段的位置相同。
3. 存储器操作数只出现在load和store中。

### 4.6.2流水线冒险

流水线中有一种情况，在下一个时钟周期中下一条指令无法执行。这种情况叫做**冒险**。

> **结构冒险**
>
> 因缺乏硬件支持而导致指令不能在预定的时钟周期内执行的情况。

多条指令在同一时钟周期使用同一个硬件资源时：

```bash
lw x1, 0(x2)
sw x3, 4(x2)
```

> **数据冒险**
>
> 因无法提供指令执行所需数据而导致指令不能在预期的时钟周期内执行。

数据冒险源于一条指令依赖于前面一条尚在流水线中的指令：

```bash
add x19, x0, x1
sub x2, x19, x3
```

这会导致`sub`所在指令流水线不得不在**ID**阶段等待，这将浪费三个时钟周期。

或许可以通过编译器消除这些冒险，但是面对大量的此类情况效果甚微。

一种基本的解决方案是通过**向内部资源添加额外的硬件以尽快找到缺少的运算项的方法**。

> **前递或旁路**：提前从内部缓冲中取到数据，而不是等到数据到达程序员可见的寄存器或存储器。

如果对于下面这种情况：

```bash
lw x3, 0(x1)
add x4, x3, x2
```

> **载入 - 使用型数据冒险**：指当载入指令要取的数据还没取回时，其他指令就需要该数据的情况。

这将浪费四个时钟周期。

第二种方案是**气泡**。

> **流水线停顿**：为了解决冒险而实施的一种阻塞。

也就是对第二个指令适当停顿。这个过程直到第二条指令被取出并译码后才知道是否需要停顿。

第三种方案是**代码重新排序**，比如下面这个例子。

```bash
lw  x1, 0(x31)
lw  x2, 8(x31)
add x3, x1, x2
sw  x3, 24(x31)
lw  x4, 16(x31)
add x5, x1, x4
sw  x5, 32(x31)
```

简单重排后得到的指令序列将比原始版本快两个时钟周期。

```bash
lw  x1, 0(x31)
lw  x2, 8(x31)
lw  x4, 16(x31)
add x3, x1, x2
sw  x3, 24(x31)
add x5, x1, x4
sw  x5, 32(x31)
```

> **控制冒险**
>
> 也叫**分支冒险**。由于取到的指令并不是所需要的，或者指令地址的流向不是流水线所预期的，导致正确的指令无法在正确的时钟周期内执行。

在条件分支指令中，取出分支指令后，紧接着在下一个时钟周期就会取下一条指令。流水线不能确定下一条指令是哪一条。具体地说：

```bash
beq x1, x2, L1
add x3, x4, x5
...
L1:
and x9, x10, x11
```

`beq`只在**EX**才能比较`x1`和`x2`，如果`x1`=`x2`，那么第二条指令的**IF**理应在`beq`的**EX**阶段结束才进行（或者以一种方式abort掉）。

第一种方案是停顿，显而易见，代价不小。

第二种方案是**预测**，一旦发生预测错误，就回滚。

- 一种简单的方法是总是预测（不）发生跳转，若最终判断要跳转，就清空错误的指令。

- > **分支预测**
  > 预测分支的结果并沿预测方向执行，而不是等分支结果确定后才开始执行。 

  预测一些条件分支指令发生跳转，而另一些不发生跳转。
  简单来说，是根据每个条件分支是否发生分支的历史记录，根据最近的过去行为来预测未来。

  具体的细节在以后阐述。动态分支预测器的正确率超过$90\%$。

第三种方案是**延迟决定**。

延迟转移顺序执行延迟槽中指令，并在该指令后再执行分支。

> 编译器通常的填充策略：
>
> 1. 把**有用的计算指令**提前到延迟槽（避免浪费）。
> 2. 如果没有合适的指令，就放一条**空操作**（`nop`）。

这种做法在现代超标量或乱序 CPU 中几乎废弃。

---

较长的流水线会恶化预测的性能，并增加预测错误的代价。

### 4.6.3总结

流水线技术是一种在顺序指令流中开发指令间**并行性**的技术。与多处理器编程相比其优点在于它对程序员是不可见的。

> 除存储系统以外，流水线的有效操作是决定处理器CPI及其性能的最重要因素。

> 结构冒险通常出现在浮点单元周围，而浮点单元可能不是完全流水线化的。
>
> 控制冒险通常出现在定点程序中，因为其中条件分支指令出现的频率更高，也更难预测。
>
> 数据冒险在定点和浮点程序中都可能成为性能瓶颈：
>
> - 浮点程序中的数据冒险通常更容易处理，因为其中条件分支指令的频率更低并且存储访问更规则，这使编译器能够调度指令以避免冒险。
> - 定点程序的存储器访问更不规则且包含大量指针，实现这样的优化更困难。

## 4.7流水线数据通路和控制

数据通路被划分成五个部分：

1. **IF**：取指令。
2. **ID**：指令译码和读寄存器堆。
3. **EX**：执行或计算地址。
4. **MEM**：存储器访问。
5. **WB**：写回。

![image-20251030101202903](.\pictures\image-20251030101202903.png)

如果执行

```bash
lw x1, 100(x4)
lw x2, 200(x4)
lw x3, 400(x4)
```

看起来三条指令需要三条数据通路。

通过**引入寄存器保存数据**，部分数据通路可以在指令执行的过程中被共享。

例如：指令寄存器只在指令的**IF**阶段使用，为了后四个阶段还能保留指令，可以把从指令寄存器中读取的数据保存在寄存器中。

![image-20251030103226907](.\pictures\image-20251030103226907.png)

> **IF/ID**寄存器的位宽必须为96位，包括存储器中提取出的32位指令以及自增的64位PC地址。目前，其它三个流水线寄存器位宽分别为256位、193位和128位。

**PC**也可被看作一个流水线寄存器，它给**IF**阶段提供数据。
不同的是，在发生**例外(异常）**时，**PC**的内容必须被保存。

---

下面给出很多图显示了`lw`在通过流水线的五个阶段。其中左半阴影表示被**写入**，右半阴影表示被**读取**。

![image-20251030105157630](.\pictures\image-20251030105157630.png)

1. **取指**：**PC**指令进入**IF/ID**，**PC**自增4。

![image-20251030105222726](.\pictures\image-20251030105222726.png)

2. **指令译码和读寄存器堆**：**Imm**和寄存器编号和**PC**地址都被放入**ID/EX**。

![image-20251030105434760](.\pictures\image-20251030105434760.png)

3. **执行或计算地址**：读取一个寄存器的值和**Imm**，加和存入**EX/MEM**。

![image-20251030105457715](.\pictures\image-20251030105457715.png)

4. **存储器访问**：读取存入**MEM/WB**。

![image-20251030105518631](.\pictures\image-20251030105518631.png)

5. **写回**：写回。

> 你可能好奇**rd**（目标寄存器）如何确定，会不会要在写回阶段再读**IF/ID**呢（显然不会，因为此时**IF/ID**可能都不存当前指令了。事实上**rd**被解析到**IF/ID**，随着流水线寄存器行走。
>
> ~~我醉了，教材后面才指出这个问题并给了一个修正版。~~
>
> ![image-20251030112629111](.\pictures\image-20251030112629111.png)

存储指令留作读者思考。

**每一个逻辑部件只能在单个流水线阶段中被使用，否则发生结构冒险**。

### 4.7.1流水线的图形化表示

**多时钟周期流水线图**，考虑：

```bash
lw  x10, 40(x1)
sub x11, x2, x3
add x12, x3, x4
lw  x13, 48(x1)
add x14, x5, x6
```

同样地，左半阴影表示被**写入**，右半阴影表示被**读取**。

![image-20251104223934423](.\pictures\1.计算机抽象及相关技术.md)

**单时钟周期流水线图**显示了在一个单时钟周期内整个数据通路的状态，

![image-20251104225819556](.\pictures\image-20251104225819556.png)

### 4.7.2流水线控制

我们要将控制添加到流水线数据通路中。

第一步是在现有的数据通路上标记控制线。

![image-20251104230200355](.\pictures\image-20251104230200355.png)

与单周期实现的情况一样，假定**PC**在每个时钟周期被写入，因此**PC**没有单独的写入信号，流水线寄存器也是如此，因为它们也在每个时钟周期内被写入。

因为每条控制线都只与一个流水线阶段中的功能部件相关，所以可以把控制线划分为五组。

1. **取指**：该指令存储器和写**PC**的控制信号总是有效的，因此这个阶段没有什么需要特别控制的内容。
2. **指令译码和读寄存器堆**：在**RISC-V**指令格式中两个源寄存器总是位于相同的位置，因此在这个阶段也没有什么需要特别控制的内容。
3. **执行或计算地址**：设置**ALUOp**和**ALUSrc**。
4. **存储器访问**：设置**Branch**、**MemRead**和**MemWrite**。
5. **写回**：设置**MemtoReg**和**RegWrite**。

![image-20251104231752972](.\pictures\image-20251104231752972.png)

![image-20251104231820186](.\pictures\image-20251104231820186.png)

## 4.8数据冒险：前递与停顿

看一个存在更多相关的指令序列：

```bash
sub  x2, x1, x3
and  x12, x2, x5
or   x13, x6, x2
add  x14, x2, x2
sd   x15, 100(x2)
```

后四个指令都依赖于第一条指令的修改。

![image-20251106095136842](.\pictures\image-20251106095136842.png)

`sw`指令不会发生数据冒险。我们研究一下`add`指令：

这一个潜在的冒险可以通过寄存器堆的硬件设计来解决：**假定写操作发生在一个时钟周期的前半部分，读操作发生在后半部分**。

`and`和`or`指令会发生数据冒险：但我们发现，如果可以把`sub`指令**EX**阶段结果前递给等待该数据的单元，就不需要停顿地执行这段指令。

书上采取一种诡异的文法检测冒险：

- 定义**ID/EX.RegisterRs1**表示一个寄存器的编号，它的值在**ID/EX**中。可以得到两对冒险的条件：
  - **EX/MEM.RegisterRd=ID/EX.RegisterRs1**
  - **EX/MEM.RegisterRd=ID/EX.RegisterRs2**
  - **MEM/WB.RegisterRd=ID/EX.RegisterRs1**
  - **MEM/WB.RegisterRd=ID/EX.RegisterRs2**

`and`指令的数据冒险可以由第一个条件表示，`or`指令的数据冒险可以由第四个条件表示。

额外修正：

- 如果指令不会写回寄存器，那就不需要前递，这可以通过检查**RegWrite**判断。
- 考虑`x0`这个特殊的寄存器，我们还要要求**EX/MEM.RegisterRd≠0**，**MEM/WB.RegisterRd≠0**。

---

![image-20251106101200750](.\pictures\image-20251106101200750.png)

通过在**ALU**输入上添加多选器再辅以适当的控制，就可以在存在数据冒险的情况下全速运行流水线。

![image-20251106101624752](.\pictures\image-20251106101624752.png)

![image-20251106101640860](.\pictures\image-20251106101640860.png)

你可以发现，现在需要让**ID/EX**留出存储**Rs1**和**Rs2**的存储空间。

~~试着自己补充前递信号？~~

只要满足某个冒险条件，我们就会修改**Forward**信号，实现前递。

![image-20251106103002353](.\pictures\image-20251106103002353.png)

---

当一条指令在加载指令写入一个寄存器之后读这个寄存器，前递不能解决此处的冒险。此时必须阻塞以消除这种指令组合带来的冒险。

![image-20251106103419262](.\pictures\image-20251106103419262.png)

如果**EX**阶段的加载指令的目标寄存器与**ID**阶段的指令中的某一个源寄存器相匹配，那么后者就会停顿一个时钟周期，具体是：

- 如果处于**ID**阶段的指令被停顿了，那么在**IF**阶段中的指令也要被停顿，否则已经取到的指令就会丢失。这可以通过禁止**PC**和**IF/ID**的改变。
- **EX**阶段开始的流水线后半部分必须执行**空指令（通过设置控制这些阶段的信号为0）**。

![image-20251106105727232](.\pictures\image-20251106105727232.png)

为此，我们需要一个**冒险检测单元**。

![image-20251106105750806](.\pictures\image-20251106105750806.png)

## 4.9控制冒险

![image-20251106110111386](.\pictures\image-20251106110111386.png)

因为是否跳转在**DM**才决定，所以如果不加干预，后3个指令会偷偷执行。

### 4.9.1假设分支不发生

一种提升分支阻塞效率的方法是**预测**条件分支不发生并持续执行顺序指令流，一旦条件分支发生，已经被读取和译码的指令就将被**丢弃**。

### 4.9.2缩短分支延迟

书上给了令人**绝望**的一页字，大致说的是：

一种提升条件分支性能的方式是**减少发生分支时所需的代价**：如果将流水线中的条件分支指令提早移动执行，就可以刷新更少的指令，这需要两个操作提早发生：

- 计算分支目标地址：把**EX**阶段得到的分支地址移动到**ID**阶段。
- 分支决定：
  - 在**ID**阶段将指令译码，决定是否要将指令旁路至检测单元，并且完成测试以防要发生分支，如果是，就把**PC**设置为分支目标地址。麻烦的是，这需要添加新的前递逻辑，于是有了**冲突检测单元**。
  - 在**ID**阶段分支比较所需的值可能还会发生改变，因此会发生数据冒险。例如：
    - 如果一条**ALU**指令在分支指令之前且产生条件分支检测所需的操作数，那么对分支指令停顿是必要的。
    - 如果加载指令在分支指令之后，并且分支指令依赖加载指令的结果，那么对加载指令停顿是必要的。

```bash
36 sub  x10, x4, x8
40 beq  x1,  x3, 16
44 and  x12, x2, x5
48 or   x13, x2, x6
52 add  x14, x4, x2
56 sub  x15, x6, x7
...
72 lw   x4, 50(x7)
```

![image-20251106144519015](.\pictures\image-20251106144519015.png)

上面是第三、四个时钟周期的单周期流水线图。

注意：图中添加了**IF.Flush**控制线，它用来清除**IF/ID** 。

### 4.9.3动态分支预测

> **动态分支预测**：在程序运行时使用运行信息进行分支预测。

这里采用一种策略：检查指令中的地址，查看上一次该指令执行时条件分支是否发生的跳转，如果发生了，则从上一次执行的地址中取出指令。

> **分支预测缓存**：也称分支历史表，一块按照分支指令的低位地址定位的小容量存储器，包含一个或多个比特以表明一个分支最近是否发生了跳转。

分支预测缓存是一块按照分支指令的地位地址定位的小容量存储器，包含一个比特，表明一个分支最近是否发生了跳转。

我们会依赖存储器提供的假设跳转，如果这个假设是错误的，那就把它取反。

> [!NOTE]
>
> 现在考虑一个循环分支，它在一行代码中发生了$9$次跳转，之后产生$1$次未跳转。假定这个分支的预测位在预测缓存中，则这条分支指令的预测正确率为$80\%$（首次和最后一次）。

这个例子中：

- 如果连续发生跳转的次数更多，那么预测正确率必然会更高，然而如果**跳转未跳转交替发生**，或者更复杂的情况，正确率并不会很高。
- 理想状态下，对于规律性很强的分支来说：分支预测的准确率应该与分支发生的频率相匹配。通常我们采用更多的预测位机制。
- 在$2$位预测机制中，只有在发生两次错误时预测结果才会被改变。如图：![image-20251111182450256](.\pictures\image-20251111182450256.png)

> **分支目标缓存**：一个缓存分支目标**PC**值或目标指令的结构。通常被组织为一个带有标记的缓存，相比简单的预测缓存需要更多的硬件消耗。

分支预测缓存可以被实现为一个小而专用的、可以被**IF**阶段的指令地址所访问的缓存。

如果指令被预测为跳转，一旦新的**PC**已知就开始从目标地址取指，这个操作可以被前移至**ID**阶段。

> **相关预测器**：一种组合了特殊分支指令的局部行为和最近执行的一些分支指令的全局行为信息的分支预测器。

研究表明，对于相同的预测位，同时使用局部分支和最近执行分支的全局行为的信息能获得更好的预测准确率。

> **锦标赛分支预测器**：一个对于每个分支具有多种预测的分支预测器，其具有一种选择机制，该机制选择对于给定分支选择哪个预测器作为预测结果。

选择基于局部信息和基于全局分支行为中更准确的那个。

### 4.9.4流水线总结

![image-20251111183407164](.\pictures\image-20251111183407164.png)

## 4.10例外

> **例外**：也称异常，与中断并指那些打断程序正常执行的意外事件，比如未定义指令。

> **终端**：来自于处理器外部的例外，一些体系结构也会使用中断表示所有的例外。

这个概念有些模糊，我们做一下修正：

> [!NOTE]
>
> **异常（例外）(Exception)**：指代意外的控制流变化。
>
> **中断（Interrupt）**：指代由处理器外部事件引发的控制流变化。

| 事件类型                 | 例外来源 | RISC-V中的表示 |
| ------------------------ | -------- | -------------- |
| 系统重启                 | 外部     | 异常           |
| I/O设备请求              | 外部     | 中断           |
| 用户程序进行操作系统调用 | 内部     | 异常           |
| 未定义指令               | 内部     | 异常           |
| 硬件故障                 | 皆可     | Both           |

### 4.10.1RISC-V体系结构中如何处理异常

> **SEPC**：64位寄存器，用来保存引起例外的指令的地址。
>
> **SCAUSE**：用来记录例外原因的寄存器。**RISC-V**中该寄存器为$64$位，大多数为未被使用。（未定义指令为$2$，硬件故障为$12$）。

发生异常时，控制权将转交给操作系统，由操作系统根据异常原因做出操作。

获得异常原因的方法：

- 通过**SCAUSE**获得异常原因，这是**RISC-V**使用的方法。

- **向量式中断**：

  设置一个**基址寄存器**，保存了向量式中断内存区域的起始地址。

  | 异常类型   | 偏移       |
  | ---------- | ---------- |
  | 未定义指令 | 0001000000 |
  | 硬件故障   | 0110000000 |

  具体来说，用基址寄存器的起始地址加上偏移，来到对应异常处理的区域（$32$字节或$8$条指令大小的区域），供操作系统记录异常原因并进行简单处理。


### 4.10.2流水线实现中的异常

流水线把异常处理看成另一种控制冒险，具体来说：

- 为**PC**多选器新增一个输入，在**RISC-V**中这个输入是`0000 0000 1C09 0000`作为异常入口地址。
- 发生异常时，清楚当前指令的执行（具体来说：$flush$掉异常发生阶段之前的流水线寄存器，异常发生阶段之后的指令正常执行），在**SEPC**保存当前执行的指令地址（而不是下一个指令地址），**PC**跳转到异常入口地址。

![image-20251111220139467](.\pictures\image-20251111220139467.png)

一个周期可能发生多个异常，**RISC-V**的方案是按照**固定的硬件优先级规则**处理异常。通常**异常**比**中断**优先级高，**SCAUSE**当然记录最高优先级的异常信息。

另外，部分异常的处理机制相同，比如**I/O设备请求**和**硬件故障**，它们的处理机制可以复用。

## 4.11指令间的并行性

之前我们接触了流水线实现的**指令级并行（ILP）**，还有一种提高指令级并行度的方法是**多发射**。

> **多发射**：一个时钟周期内可以发射多条指令的策略。

显然这个技术实现稍显复杂，还需要考虑哪些指令可以同时执行（这部分指令会打包并放入**发射槽**），可能更多的冒险。

> **静态多发射**：多发射的一种实现方法：由编译器判断哪些指令发射。

> **动态多发射**：多发射的一种实现方法：由硬件完成发射相关判断。

### 4.11.2静态多发射

> **发射指令包**：同一周期发射的指令组合。可能是由编译器静态打包，也可能是由处理器在动态执行过程中进行调度。

> **超长指令字**：一种类型的指令系统体系结构，支持在单条指令中使用不同的编码位来定义多个可同时被发射的独立操作。

静态多发射处理器会将**发射指令包**看成一条预先定义好、需要进行多种操作的指令。

一些处理器为简化指令的译码和发射，对可同时发射的指令组合做出了限制，双发射**RISC-V**处理器为例：

- 指令成对。
- 指令地址需要64位边界对齐。
- **ALU**指令和分支指令放在前面。
- 当怎样都有一条指令需要单独发射，给它组合**nop**指令。

对于冒险：

- 编译器解决**所有**的冒险，完成代码调度和**nop**插入。
- 硬件检测两个指令包之间数据冒险，产生流水线停顿。编译器只负责单个指令包中的类型相关。

假设采取第二种处理冒险的方法：

首先要添加：

- 寄存器堆的读写口（同一个时钟周期内，**ALU**指令需要读取两个源寄存器，**store**指令可能需要读两个以上的源寄存器；**ALU**和**load**指令也都需要更新一个目标寄存器）以避免**结构冒险**。

另外，**load**指令有一个周期的**使用延迟**，如果后续指令使用**load**的结果，必须停顿一周期。在双发射下，这将停顿后续两条指令的执行。

另另外，双发射下，同时发射**ALU**和**l/s**指令，如果它们本身就有数据冒险，那么有一个会被替换为**nop**，这将导致**ALU**也具有**使用延迟**。

![image-20251112114720769](.\pictures\image-20251112114720769.png)

> **循环展开**：一种针对数组访问循环体的提高程序性能的技术。它将循环体展开多遍，对不同循环内的指令进行统一调度。

> **反相关**：也叫名字相关，由于名字复用被迫导致的顺序排列。

> **寄存器重命名**：编译器或硬件对寄存器进行重命名，消除指令序列中的反相关。

我们看一个例子就能清晰地明白程序是如何通过**循环展开**结合**寄存器重命名**完成优美的优化。

```bash
Loop: lw   x31, 0(x20)
      add  x31, x31, x21
      sw   x31, 0(x20)
      addi x20, x20, -4
      blt  x22, x20, Loop
```

上述代码实现功能如下：

```c++
for(int i=0;i<n;++i){
    a[i]+=constant;
}
```

双发射流水线进行调度后：

|       | ALU或branch指令      | 数据传输指令     | 时钟周期 |
| ----- | -------------------- | ---------------- | -------- |
| Loop: | `nop`                | `lw x31, 0(x20)` | 1        |
|       | `addi x20, x20, -4`  | `nop`            | 2        |
|       | `add x31, x31, x21`  | `nop`            | 3        |
|       | `blt x22, x20, Loop` | `sw x31, 4(x20)` | 4        |

循环展开（4重）后：

|       | ALU或branch指令      | 数据传输指令      | 时钟周期 |
| ----- | -------------------- | ----------------- | -------- |
| Loop: | `addi x20, x20, -16` | `lw x28 0(x20)`   | 1        |
|       | `nop`                | `lw x29, 12(x20)` | 2        |
|       | `add x28, x28, x21`  | `lw x30, 8(x20)`  | 3        |
|       | `add x29, x29, x21`  | `lw x31, 4(x20)`  | 4        |
|       | `add x30, x30, x21`  | `sw x28, 16(x20)` | 5        |
|       | `add x30, x30, x21`  | `sw x29, 12(x20)` | 6        |
|       | `nop`                | `sw x30, 8(x20)`  | 7        |
|       | `blt x22, x20, Loop` | `sw x31, 4(x20)`  | 8        |

这使得流水线性能提高了$1$倍以上。

### 4.11.3动态多发射

有些困难，略。

## 4.15谬误与陷阱

**谬误：流水线是简单的**。

**谬误：对于流水线等结构设计，可以与工艺无关**。

**陷阱：缺乏对指令系统设计的考虑反过来会影响流水线的实现**。
