# 2.指令:计算机的语言

我们介绍$\mathbf{RISC-V}$。

## 2.1引言

**存储程序概念**：指令与多种类型的数据不加区别地存储在存储器中并因此易于更改，因此产生了存储程序计算机。

**RISC-V操作数**

| 名字         | 示例                                                  | 注解                                                         |
| ------------ | ----------------------------------------------------- | ------------------------------------------------------------ |
| $32$个寄存器 | $x_0\sim x_{31}$                                      | 快速定位数据。在RISC-V中，只对在寄存器中的数据执行算术运算   |
| 存储器       | $\mathrm{Memory[0],...,Memory[18446744073709551608]}$ | 只能被数据传输指令访问。RISC-V使用字节寻址，因此顺序双字访问相差8。存储器保存数据结构、数组和换出的寄存器的内容 |

**RISC-V汇编语言**

| 类别           | 指令                   | 示例                | 含义                      | 注解                                                     |
| -------------- | ---------------------- | ------------------- | ------------------------- | -------------------------------------------------------- |
| **算术运算**   | 加                     | `add x5, x6, x7`    | `x5=x6+x7`                | 三寄存器操作数：加                                       |
|                | 减                     | `sub x5, x6, x7`    | `x5=x6-x7`                | 三寄存器操作数：减                                       |
|                | 立即数加               | `addi x5, x6, 20`   | `x5=x6+20`                | 用于加常数                                               |
| **数据传输**   | 取双字                 | `ld x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取双字到寄存器                                   |
|                | 存双字                 | `sd x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存双字到存储器                                   |
|                | 取字                   | `lw x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取字到寄存器                                     |
|                | 取字(无符号)           | `lwu x5, 40(x6)`    | `x5=Memory[x6+40]`        | 从存储器取无符号字到寄存器                               |
|                | 存字                   | `sw x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存字到存储器                                     |
|                | 取半字                 | `lh x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取半字到寄存器                                   |
|                | 取半字(无符号)         | `lhu x5, 40(x6)`    | `x5=Memory[x6+40]`        | 从存储器取无符号半字到寄存器                             |
|                | 存半字                 | `sh x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存半字到存储器                                   |
|                | 取字节                 | `lb x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取字节到寄存器                                   |
|                | 取字节(无符号)         | `lbu x5, 40(x6)`    | `Memory[x6+40]=x5`        | 从寄存器存字节到存储器                                   |
|                | 存字节                 | `sb x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存字节到存储器                                   |
|                | 取保留字               | `lr.d x5, (x6)`     | `x5=Memory[x6]`           | 取；原子交换的前半部分                                   |
|                | 存条件字               | `sc.d x7, x5, (x6)` | `Memory[x6]=x5;x7=0/1`    | 存；原子交换的后半部分                                   |
|                | 取立即数高位           | `lui x5, 0x12345`   | `x5=0x12345000`           | 取左移12位后的20位立即数                                 |
| **逻辑运算**   | 与                     | `and x5, x6, x7`    | `x5=x6&x7`                | 三寄存器操作数：按位与                                   |
|                | 或                     | `or x5, x6, x8`     | `x5=x6|x8`                | 三寄存器操作数：按位或                                   |
|                | 异或                   | `xor x5, x6, x9`    | `x5=x6^x9`                | 三寄存器操作数：按位异或                                 |
|                | 与立即数               | `andi x5, x6, 20`   | `x5=x6&20`                | 寄存器与常数按位与                                       |
|                | 或立即数               | `ori x5, x6, 20`    | `x5=x6|20`                | 寄存器与常数按位或                                       |
|                | 异或立即数             | `xori x5, x6, 20`   | `x5=x6^20`                | 寄存器与常数按位异或                                     |
| **移位操作**   | 逻辑左移               | `sll x5, x6, x7`    | `x5=x6<<x7`               | 按寄存器给定位数左移                                     |
|                | 逻辑右移               | `srl x5, x6, x7`    | `x5=x6>>x7`               | 按寄存器给定位数右移                                     |
|                | 算术右移               | `sra x5, x6, x7`    | `x5=x6>>x7`               | 按寄存器给定位数算术右移                                 |
|                | 逻辑左移立即数         | `slli x5, x6, 3`    | `x5=x6<<3`                | 根据立即数给定位数左移                                   |
|                | 逻辑右移立即数         | `srli x5, x6, 3`    | `x5=x6>>3`                | 根据立即数给定位数右移                                   |
|                | 算术右移立即数         | `srai x5, x6, 3`    | `x5=x6>>3`                | 根据立即数给定位数算术右移                               |
| **条件分支**   | 相等即跳转             | `beq x5, x6, 100`   | `if(x5==x6) go to PC+100` | 若寄存器数值相等则跳转到PC相对地址                       |
|                | 不等即跳转             | `bne x5, x6, 100`   | `if(x5!=x6) go to PC+100` | 若寄存器数值不等则跳转到PC相对地址                       |
|                | 小于即跳转             | `blt x5, x6, 100`   | `if(x5<x6) go to PC+100`  | 若寄存器数值比较结果小于则跳转到PC相对地址               |
|                | 大于等于即跳转         | `bge x5, x6, 100`   | `if(x5>=x6) go to PC+100` | 若寄存器数值比较结果大于或等于则跳转到PC相对地址         |
|                | 小于即跳转(无符号)     | `bltu x5, x6, 100`  | `if(x5<x6) go to PC+100`  | 若寄存器数值比较结果小于则跳转到PC相对地址(无符号)       |
|                | 大于等于即跳转(无符号) | `bgeu x5, x6, 100`  | `if(x5>=x6) go to PC+100` | 若寄存器数值比较结果大于或等于则跳转到PC相对地址(无符号) |
| **无条件跳转** | 跳转-链接              | `jal x1, 100`       | `x1=PC+4; go to PC+100`   | 用于PC相关的过程调用                                     |
|                | 跳转-链接(寄存器地址)  | `jalr x1, 100(x5)`  | `x1=PC+4; go to x5+100`   | 用于过程返回；非直接调用                                 |

## 2.2计算机硬件的操作

**设计原则1：简单源于规整**：操作数不可变。

## 2.3计算机硬件的操作数

**字**：访问基本单位，32位一组。

**双字**：访问基本单位，64位一组，对应RISC-V中寄存器大小。

**设计原则2：更少则更快**：数量过多的寄存器可能会增加时钟周期，因为电信号传输的距离越远，所花费的时间就越长。

### 2.3.1存储器操作数

算术运算操作只作用于寄存器，而**数据传输指令**用于内存和寄存器之间传输数据。

**基址寄存器**：存放基址的寄存器。

**结构内存分配**：编译器会将数组和结构体这样的数据结构分配到内存中的相应位置，将正确的起始地址放入数据传输指令中。

> RISC-V是小端寻址。

**对齐限制**：数据在内存中要与自然边界对齐的要求，字和双字的起始地址必须分别是4和8的倍数。但是在**RISC-V**没有对齐限制。

**寄存器换出**：编译器会尽量把最常用的变量存放在寄存器中，剩下的存放在内存中。

### 2.3.2常数或立即数操作数

**x0寄存器硬连线到常数0**。

> 尽管RISC-V寄存器为64位宽，但作者仍构思了ISA的多种变体：RV32变体就是32位宽，成本较低。

## 2.4有符号数与无符号数

**原码**：最高位为符号位的数据表示方法，例如$10000010$表示$-2$。

**补码**：一种美妙的有符号数表示方法，使得有符号数的计算可以直接进行。对于补码表示的负数$z$，其值为$z$各位取反再加$1$的相反数，例如$11111100$表示$-4$。

**符号扩展**：用符号位填充扩展的位。

## 2.5计算机中的指令表示

**指令格式**：一条汇编指令通常会被$Assembler$转化为机器指令，这个指令可以被CPU直接读取。在RISC-V中，机器指令都是32位长。

**机器语言**：为了区分汇编语言，我们将指令的数字表示为**机器语言**，这样的指令序列叫作**机器码**。

下面我们具体地介绍**RISC-V字段**：

**R型**：

| funct7 | rs2  | rs1  | funct3 | rd   | opcode |
| ------ | ---- | ---- | ------ | ---- | ------ |
| 7位    | 5位  | 5位  | 3位    | 5位  | 7位    |

- **funct7**：一个另外的操作码字段。
- **rs2**：第二个源操作数寄存器。
- **rs1**：第一个源操作数寄存器。
- **funct3**：一个另外的操作码字段。
- **rd**：目的操作数寄存器，用来存放操作结果。
- **opcode(操作码)**：指令的基本操作，这个缩写是它的惯用名称。

**I型**：

| immediate | rs1  | funct3 | rd   | opcode |
| --------- | ---- | ------ | ---- | ------ |
| 12位      | 5位  | 3位    | 5位  | 7位    |

- **immediate**：补码值。

**S型**：

| immediate[11:5] | rs2  | rs1  | funct3 | immediate[4:0] | opcode |
| --------------- | ---- | ---- | ------ | -------------- | ------ |
| 7位             | 5位  | 5位  | 3位    | 5位            | 7位    |

- 把**immediate**拆成了两部分，使得**rs**字段在相同的位置，降低硬件的复杂性。

**设计原则3：优秀的设计需要适当的折中**：设计人员保持所有的指令长度相同，对于不同的指令使用不同的指令格式。

## 2.6逻辑操作

**移位指令使用I型格式**。因为不适用于对64位寄存器移动大于63位，所以**immediate**只有低6位被使用，高6位被用作额外的操作码字段。

| fcunt6 | immediate | rs1  | funct3 | rd   | opcode |
| ------ | --------- | ---- | ------ | ---- | ------ |
| 6位    | 6位       | 5位  | 3位    | 5位  | 7位    |

> 按位取反是只有一个操作数的指令，为了保持三操作数的格式，决定用异或$-1$来实现按位取反。

## 2.7用于决策的指令

**条件分支指令**：一条指令，先检测一个值，然后根据检测结果允许后续控制流转移到程序中的一个新地址。`beq`代表**相等则分支**，`bne`代表**不等则分支**。这样带有判断和分支的指令通常称作**条件分支**指令。

> 编译器经常产生分支和标签，它们不出现在编程语言中。

### 2.7.1循环

**基本块**：一个没有分支的指令序列(除了可能在结尾处)，同时没有分支目标或分支标签(除了可能在起始处)。编译的基础工作之一就是将程序划分为基本块。

> ARM指令系统通常保留额外的位来记录指令执行期间发生的情况，这些额外的位称为**条件代码**或**标志位**。就像我们学习过的X86一样。

### 2.7.2边界检查的简便方法

我们要求下标是$0$到$n$之间的整数。显然可以通过无符号比较的方法完成这个边界检查。

### 2.7.3case/switch语句

**分支地址表(分支表)**：一种包含了不同指令序列地址的表，相当于一个双字数组，包含与代码中标签对应的地址。

RISC-V中跳转-链接指令(`jalr`)可以对寄存器中指定的地址执行无条件跳转。

## 2.8计算机硬件对过程的支持

**过程**：一个根据给定参数执行特定任务的已存储的子程序，相当于函数。

**跳转-链接指令**：跳转到某个地址的同时将下一条指令的地址保存在寄存器。(RISC-V中通常是`x1`中的指令)。

在执行过程时，通常有以下步骤：

1. 将参数放在过程可以访问到的位置。
2. 将控制转交给过程。
3. 获取过程所需的存储资源。
4. 执行所需的任务。
5. 将结果值放在调用程序可以访问到的位置。
6. 将控制返回到初始点，因为过程可以从程序中的多个点调用。

RISC-V为过程调用分配寄存器有如下约定：

- `x10`~`x17`：八个参数寄存器，用于传递参数或返回值。
- `x1`：一个返回地址寄存器，用于返回到起始点。

**跳转-链接指令(`jal`)**：跳转并将返回地址写入`x1`。

**程序计数器(PC)**：用来保存当前执行指令的地址。

### 2.8.1使用更多的寄存器

**栈**：被用于寄存器换出。

**栈指针**：`x2`，也叫做`sp`。

通常是向低地址**压栈**，向高地址**弹栈**。

于是又引出更多寄存器的规定：

- `x5`~`x7`和`x28`~`x31`：临时寄存器，在过程调用中不被被调用者保存。
- `x8`~`x9`和`x18`~`x27`：保存寄存器，在过程调用中必须被保存。(一旦使用，由被调用者保存并恢复)。

### 2.8.2嵌套过程

**函数调用**：

1. 调用者将所有调用后还需要的参数寄存器(`x10`~`x17`)或临时寄存器(`x5`~`x7`和`x28`~`x31`)压栈。
2. 被调用者将返回地址寄存器`x1`和被调用者使用的保存寄存器(`x8`~`x9`和`x18`~`x27`)压栈。
3. 调整栈指针`sp`以计算压栈寄存器的数量。返回时，从存储器中恢复寄存器并重新调整栈指针。

| 保存                               | 不保存                            |
| ---------------------------------- | --------------------------------- |
| 保存寄存器：`x8`~`x9`，`x18`~`x27` | 临时寄存器:`x5`~`x7`，`x28`~`x31` |
| 栈指针寄存器：`x2(sp)`             | 参数/结果寄存器：`x10`~`x17`      |
| 帧指针：`x8(fp)`                   |                                   |
| 返回地址：`x1(ra)`                 |                                   |
| 栈指针以上的栈                     | 栈指针以下的栈                    |

### 2.8.3在栈中为新数据分配空间

**过程帧(活动记录)**：栈中包含过程保存的寄存器和局部变量的段。

**帧指针**：指向给定过程的局部变量和保存的寄存器地址的值。

**过程调用之中**：帧指针(`fp`或`x8`)指向帧的第一个双字，通常是**保存的参数寄存器**，栈指针(`sp`)指向栈顶，调整栈以容纳所有**保存的寄存器**和**常驻存储器的局部变量**。

如果在过程中栈内没有局部变量，编译器将不设置和不恢复帧指针以节省时间。

当使用帧指针时，在调用中使用`sp`的地址进行初始化，且可以使用`fp`恢复`sp`。

### 2.8.4在堆中为新数据分配空间

**代码段**：UNIX目标文件的段，包含源文件中例程的机器语言代码。

**静态数据段**：用于存放常量和其他静态变量的段。

**堆**：存放数组和链表这类的数据结构的段。

堆和栈在动态数据段相向而长。

以下是寄存器约定，这个约定是**加速经常性事件**的另一个例子：

| 名称        | 寄存器号 | 用途                 | 调用时是否保存 |
| ----------- | -------- | -------------------- | -------------- |
| `x0`        | 0        | 常数0                | 不适用         |
| `x1(ra)`    | 1        | 返回赋值(链接寄存器) | 是             |
| `x2(sp)`    | 2        | 栈指针               | 是             |
| `x3(gp)`    | 3        | 全局指针             | 是             |
| `x4(tp)`    | 4        | 线程指针             | 是             |
| `x5`~`x7`   | 5~7      | 临时                 | 否             |
| `x8`~`x9`   | 8~9      | 保存                 | 是             |
| `x10`~`x17` | 10~17    | 参数/结果            | 否             |
| `x18`~`x27` | 18~27    | 保存                 | 是             |
| `x28`~`x31` | 28~31    | 临时                 | 否             |

## 2.9人机交互

**加载无符号字节(lbu)**指令从内存加载一个字节，将其放在寄存器的最右边8位。

**存储字节(sb)**指令从寄存器的最右边8位取一个字节，并将其写入内存。

**加载无符号半字(lhu)**指令从内存中读取一个半字，将它放在寄存器的最右边16位，用零填充最左边的48位。

**存储半字(sh)**指令从寄存器的最右边16位取半字并将其写入内存。

## 2.10对大立即数的RISC-V编址和寻址

### 2.10.1大立即数

**取立即数高位(lui)**指令用于将20位常数加载到寄存器的第31位到第12位。将第31位的值复制填充到最左边32位，最右边的12位用0填充。

> **lui**使用新的指令格式-U型。

### 2.10.2分支中的寻址

**SB型**：这种格式可以表示从-4096到4094的偶数分支地址。

> 地址必须是偶数地址，这是因为RISC-V的地址是两字节对齐的（就像结构体中`short`类型对齐地址一样）。

| imm[12] | imm[10:5] | rs2  | rs1  | funct3 | imm[4:1] | imm[11] | opcode |
| ------- | --------- | ---- | ---- | ------ | -------- | ------- | ------ |
| 1位     | 6位       | 5位  | 5位  | 3位    | 4位      | 1位     | 7位    |

**UJ型**：只有**无条件跳转-链接(jal)**指令使用这种格式，同样只能跳转到偶数分支地址。

| imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd   | opcode |
| ------- | --------- | ------- | ---------- | ---- | ------ |
| 1位     | 10位      | 1位     | 8位        | 5位  | 7位    |

**UJ型**寻址最多可以寻址到$2^{20}$，这是远远不够的。为此我们引入**PC相对寻址**。

**PC相对寻址**：一种寻址方式，它的地址是**PC**和指令中的常量之和。

RISC-V允许使用**双指令序列**来非常长距离地跳转到任何32位地址：

`lui`将地址的第12位至第31位写入临时寄存器，`jalr`将地址的低12位加到临时寄存器并跳转到目标位置。

### 2.10.3RISC-V寻址模式总结

1. **立即数寻址**：

   **I型指令**

   操作数是指令本身的常量。

2. **寄存器寻址**：

   **R型指令**

   操作数在寄存器中。

3. **基址寻址**：

   **I型指令**

   操作数于内存中，其地址是寄存器和指令中的常量之和。

4. **PC相对寻址**

   **S型指令**

   分支地址是PC和指令中常量之和。

### 2.10.4机器语言译码

以下是指令格式。

| 类型 | 字段            |                |              |              |               |        | 备注            |
| ---- | --------------- | -------------- | ------------ | ------------ | ------------- | ------ | --------------- |
|      | 7位             | 5位            | 5位          | 3位          | 5位           | 7位    |                 |
| R型  | funct7          | rs2            | rs1          | funct3       | rd            | opcode | 算术指令格式    |
| I型  | immediate[11:5] | immediate[4:0] | rs1          | funct3       | rd            | opcode | 加载&立即数算术 |
| S型  | immed[11:5]     | rs2            | rs1          | funct3       | immed[4:0]    | opcode | 存储            |
| SB型 | immed[12,10:5]  | rs2            | rs1          | funct3       | immed[4:1,11] | opcode | 条件分支格式    |
| UJ型 | immed[20,10:5]  | immed[4:1,11]  | immed[19:15] | immed[14:12] | rd            | opcode | 无条件跳转      |
| U型  | immed[19:13]    | immed[12:8]    | immed[7:3]   | immed[2:0]   | rd            | opcode | 大立即数格式    |

以下是汇编语言与机器语言的对译。

| 类型 | 指令 | opcode  | funct3 | funct7  |
| ---- | ---- | ------- | ------ | ------- |
| R型  | add  | 0110011 | 000    | 0000000 |
|      | sub  | 0110011 | 000    | 0100000 |
|      | sll  | 0110011 | 001    | 0000000 |
|      | xor  | 0110011 | 100    | 0000000 |
|      | srl  | 0110011 | 101    | 0000000 |
|      | sra  | 0110011 | 101    | 0100000 |
|      | or   | 0110011 | 110    | 0000000 |
|      | and  | 0110011 | 111    | 0000000 |
|      | lr.d | 0110011 | 011    | 0001000 |
|      | sc.d | 0110011 | 011    | 0001100 |
| I型  | lb   | 0000011 | 000    | n.a.    |
|      | lh   | 0000011 | 001    | n.a.    |
|      | lw   | 0000011 | 010    | n.a.    |
|      | ld   | 0000011 | 011    | n.a.    |
|      | lbu  | 0000011 | 100    | n.a.    |
|      | lhu  | 0000011 | 101    | n.a.    |
|      | lwu  | 0000011 | 110    | n.a.    |
|      | addi | 0010011 | 000    | n.a.    |
|      | slli | 0010011 | 001    | 0000000 |
|      | xori | 0010011 | 100    | n.a.    |
|      | srli | 0010011 | 101    | 0000000 |
|      | srai | 0010011 | 101    | 0100000 |
|      | ori  | 0010011 | 110    | n.a.    |
|      | andi | 0010011 | 111    | n.a.    |
|      | jalr | 1100111 | 000    | n.a.    |
| S型  | sb   | 0100011 | 000    | n.a.    |
|      | sh   | 0100011 | 001    | n.a.    |
|      | sw   | 0100011 | 010    | n.a.    |
|      | sd   | 0100011 | 011    | n.a.    |
| SB型 | beq  | 1100011 | 000    | n.a.    |
|      | bne  | 1100011 | 001    | n.a.    |
|      | blt  | 1100011 | 100    | n.a.    |
|      | bge  | 1100011 | 101    | n.a.    |
|      | bltu | 1100011 | 110    | n.a.    |
|      | bgeu | 1100011 | 111    | n.a.    |
| U型  | lui  | 0110111 | n.a.   | n.a.    |
| UJ型 | jal  | 1101111 | n.a.   | n.a.    |

## 2.11指令与并行性：同步

**数据竞争**：如果来自两个不同的线程的访存请求访问同一个位置，至少有一个是写，且连续出现，那么这两次存储访问形成了数据竞争。

**硬件原语**：指的是由硬件直接支持的一类**最小且不可分割的操作**，它们可以在多处理器或多线程环境下保证执行过程不会被打断。

**LR/SC**：RISC-V使用**保留加载双字（lr.d）**的特殊加载指令和**条件存储双字（sc.d）**的特殊存储指令。如果**lr**指令指定的内存位置的内容在**sc**指令执行到同一地址之前发生了变化，则**sc**指令失败且不会将值写入内存。

**sc指令**：将（可能是不同的）寄存器的值存储在内存中，如果成功则将另一个寄存器的值更改为0，如果失败则更改为非零值。

因此，**sc.d**指定了三个寄存器：第一个用于指示原子操作失败或成功，第二个用于保存地址，第三个用于如果成功则将值存储在内存中。

## 2.12翻译并启动程序

### 2.12.1编译器（Compiler）

编译器将C程序转换为机器能理解的符号形式**汇编语言程序**。

当今的优化编译器生成的汇编语言程序很优越，有时候甚至优于人工优化。

### 2.12.2汇编器（Assembler）

**伪指令**：汇编指令的一种常见变体，可以把它看作汇编语言指令。在RISC-V中是汇编器提供的真指令的简化写法。

例如伪指令`li x1, imm`，不同的`imm`可能会采取不同的真指令写法。

**符号表**：用于匹配标签名和指令所在内存的地址的表。

汇编器会跟踪分支中使用的标签和符号表中的数据传输指令。

**UNIX系统的目标文件通常包含**：

- **目标文件头**，描述了目标文件的其他部分的大小和位置。
- **代码段**，包含机器语言代码。
- **静态数据段**，包含在程序生命周期内分配的数据（UNIX允许程序使用静态数据，它在整个程序中都存在；也允许使用动态数据，它可以根据程序的需要增长或缩小。）
- **重定位信息**，标记了在程序加载到内存时依赖于绝对地址的指令和数据。
- **符号表**，包含剩余的未定义的标签，例如外部引用。
- **调试信息**，包含有关如何编译目标模块的简明描述，以便调试器可以将机器指令与源文件相关联并使数据结构可读。

### 2.12.3链接器（Linker）

**链接器**：也叫链接编辑器，是一个系统程序，它将独立汇编的机器语言程序组合起来，并解析所有未定义的标签，最终生成可执行文件。

链接器的工作有三个步骤：

1. 将代码和数据模块按符号特征放入内存。在放入内存之后必须重定位所有模块的绝对引用。
2. 决定数据和指令标签的地址。
3. 修正内部和外部引用。

链接器生成可在计算机上运行的**可执行文件**，它不包含任何未解析的引用。

### 2.12.4加载器（Loader）

1. 读取可执行文件首部以确定正文段和数据段的大小。
2. 为正文和数据创建足够大的地址空间。
3. 将可执行文件中的指令和数据复制到内存中。
4. 将主程序的参数（如果有）复制到栈顶，
5. 初始化处理器寄存器并将栈指针指向第一个空闲位置。
6. 跳转到启动例程，将参数复制到参数寄存器中并调用程序的主例程。当主例程返回时，启动例程通过exit系统调用终止程序。

**加载器**：将目标程序放在主存中以准备执行的系统程序。

### 2.12.5动态链接库

**动态链接库**：在执行期间链接到程序的库例程。

1. 第一次调用库例程时，程序调用虚入口并执行**间接跳转**。
2. 这个跳转指向一段代码，它将一个数字放入寄存器来识别所需的库例程。
3. 跳转到**动态链接器/加载器**，**动态链接器/加载器**找到所需的例程，重新映射它，并更改间接跳转位置中的地址以指向该例程。
4. 跳转到该例程。此后调用该库例程都会直接跳转到该例程。

### 2.12.6启动Java程序

**Java字节码**：为解释Java程序而设计的指令系统中的指令。

Java代码首先被编译成**Java字节码指令系统**，没有进行任何优化。

**解释器（Interpreter）**：一个模拟指令系统体系结构的程序。逐行读取源代码，解析并立即执行，而无需事先将代码转换为机器码。

**即时编译器（JIT）**：该类编译器在运行时将已解释过的代码段翻译为宿主机上的机器语言。

> Java的转换层次结构：Java程序首先被编译成Java字节码的二进制版本，所有地址都由编译器定义。Java程序现在可以在解释器上运行，称为Java虚拟机(JVM)。程序运行时，JVM链接到Java库中所需的方法。为了获得更高的性能，JVM可以调用JIT，该编译器有选择地将方法编译为运行它的机器的本地机器语言。编译过的部分将在下次运行程序时保存，以便每次运行时速度更快。

## 2.13以C排序程序为例的汇总整理

把C翻译为汇编语言时，遵循：

1. 为变量分配寄存器。
2. 为过程体生成汇编代码。
3. 保存过程调用间的寄存器。

### 2.13.1swap过程

```c
void swap(int v[], size_t k) {
	int temp;
	temp = v[k];
	v[k] = v[k + 1];
	v[k + 1] = temp;
}
```

`x5`作为临时寄存器，`x10`和`x11`作为参数寄存器。

```bash
swap:
  slli    x6, x11, 2   // reg x6 = k * 4
  add     x6, x10, x6  // reg x6 = v + k * 4
  lw      x5, 0(x6)    // reg x5 (temp) = v[k]
  lw      x7, 4(x6)    // reg x7 = v[k + 1]
  sw      x7, 0(x6)    // v[k] = reg x7
  sw      x5, 4(x6)    // v[k + 1] = reg x5 (temp)
  jalr    x0, 0(x1)    // return to calling routine
```

### 2.13.2sort过程

这里不予展示`sort`过程。

以下是编译器优化对`sort`（冒泡排序）各项性能的影响。（具体参数省略，排序个数为`n=100000`）

| gcc优化 | 相对性能 | 时钟周期（百万） | 指令数（百万） | CPI  |
| ------- | -------- | ---------------- | -------------- | ---- |
| 无优化  | 1.00     | 158615           | 114938         | 1.38 |
| O1      | 2.37     | 66990            | 37470          | 1.79 |
| O2      | 2.38     | 66521            | 39993          | 1.66 |
| O3      | 2.41     | 65747            | 44993          | 1.46 |

同一段代码在JAVA上的表现和快速排序的表现。

| 语言 | 执行模式   | 优化选项 | 冒泡排序相对性能 | 快速排序相对性能 | 快速排序与冒泡排序加速比 |
| ---- | ---------- | -------- | ---------------- | ---------------- | ------------------------ |
| C    | 编译器     | 无优化   | 1.00             | 1.00             | 2468                     |
|      | 编译器     | O1       | 2.37             | 1.50             | 1562                     |
|      | 编译器     | O2       | 2.38             | 1.50             | 1555                     |
|      | 编译器     | O3       | 2.41             | 1.91             | 1955                     |
| Java | 解释器     | ---      | 0.12             | 0.05             | 1050                     |
|      | 即时编译器 | ---      | 2.13             | 0.29             | 388                      |

## 2.14数组与指针

在一个形如实现`v.assign(n, 0)`的程序中，比较数组和指针的区别。

在不加入优化的时候，后者相比于前者有**移位替代乘法**和**消除循环内的数组地址计算**的编译优化。

## 2.16MIPS和ARM指令集

| 特征         | RISC-V                               | MIPS                             | ARM                                              |
| ------------ | ------------------------------------ | -------------------------------- | ------------------------------------------------ |
| **性质**     | **开源免费**ISA                      | **商业授权**ISA                  | **商业授权**ISA                                  |
| **设计哲学** | 模块化、可扩展、简洁                 | 经典 RISC、流水线优化            | 高能效比、广泛应用、生态成熟                     |
| **指令集**   | 模块化 (核心+标准/自定义扩展)        | 相对固定，但有不同版本           | 演进式，有不同版本 (ARMv7, ARMv8/AArch64, ARMv9) |
| **生态系统** | **快速发展中**，潜力巨大             | 相对萎缩                         | 极其庞大成熟                                     |
| **主要优势** | 灵活性、低成本、定制化、无专利壁垒   | 历史悠久，特定领域性能不错       | **市场领导者**，能效比高，生态最完善             |
| **主要应用** | 嵌入式、IoT、AI、HPC、通用计算       | 过去是路由器、消费电子；现在较少 | 移动设备、嵌入式、服务器、汽车                   |
| **商业模式** | 使用免费，可自己设计核心或使用第三方 | 购买授权                         | 购买架构/核心 IP 授权                            |

## 2.17RISC-V指令系统的剩余部分

| 名称    | 格式 | 描述                                                         |
| ------- | ---- | ------------------------------------------------------------ |
| `auipc` | U    | 立即数高20位与PC相加；将结果写到寄存器                       |
| `slt`   | R    | 比较寄存器，如果小于就设置，将布尔结果写到寄存器             |
| `sltu`  | R    | 比较寄存器，如果小于就设置（无符号），将布尔结果写到寄存器   |
| `slti`  | I    | 比较寄存器，如果小于就设置（立即数）；将布尔结果写到寄存器   |
| `sltiu` | I    | 比较寄存器，如果小于就设置（无符号立即数）；将布尔结果写到寄存器 |

下面列出了五个标准扩展：

| 助记符 | 描述          | 指令数 |
| ------ | ------------- | ------ |
| **I**  | 基本体系结构  | 51     |
| **M**  | 整数乘法/除法 | 13     |
| **A**  | 原子操作      | 22     |
| **F**  | 单精度浮点    | 30     |
| **D**  | 双精度浮点    | 32     |
| **C**  | 压缩指令      | 36     |

我们会在第三章讲述**M,F,D**三种扩展。

**A**扩展包括`lr.d`，`sc.d`以及它们的32位版本`lr.w`，`sc.w`。剩余18条指令是常见同步模式的优化。

**C**扩展会缩短指令位数以对于部分操作提高性能。

## 2.22谬误与陷阱

**谬误：更强大的指令意味着更高的性能**

**谬误：用汇编语言编程以获得最高性能**

**谬误：商用计算机二进制兼容的重要性意味着成功的指令系统无需改变**

**陷阱：忘记在字节寻址的机器中，连续的字地址相差不为1**

**陷阱：在变量的定义过程外，使用一个指针指向该变量**
